- [ ] move the extra move validation out of websockets and into a separate interfaces module (not core)
  - [ ] "can't move for another player", "can't move when you're a spectator", etc.
- [ ] allow refreshing of the browser without destroying the game
  - [ ] or just don't allow refreshing of the page, or do an 'alert' to tell them it will end the game
- [ ] organize code
  - [ ] core
      - [ ] pieces
      - [ ] ...
  - [ ] UIs
- [ ] move history
- [ ] load testing
- [ ] consider [socketify][1] for performance if you're going to stay with Python
- [ ] make or find more tests
    - [ ] could it ever be illegal to make the same move as a pawn when it's promoting with another piece?
        - this is how the pawn promotion move is tested once the promotion piece type is chosen
- [ ] reorganize code into smaller modules
- [ ] find shortcuts to limit computation and storage
  - [ ] cache possible moves for every board
    - [ ] look in this cache before trying to calculate
  - [ ] if a pawn, king, knight is sufficiently far away, no need to check whether it can put the opposing king in check
  - [ ] bitpacking?
  - [ ] persist/serialize the board differently
    - instead of FEN, maybe a hash
    - [bitboard](https://blog.devgenius.io/improve-as-a-software-engineer-by-writing-a-chess-engine-c360109371aa)
- [ ] game clock
- [ ] allow disconnect/reconnect within X seconds
- [ ] enforce move limit (draw)
- [ ] threefold repetition
- [ ] material tracking - points, pieces
- [ ] accounts/auth
- [ ] detect cheating
- [ ] switch to socketify for "create_game" if that worked out

[1]: https://docs.socketify.dev/websockets-backpressure.html
