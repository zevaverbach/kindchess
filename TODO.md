- [x] create a basic DB
  - [x] use sqlite for completed games
    - [x] fields: uid and moves
    - [x] a function to store a completed game
  - [x] use Redis at first for the active games
    - [x] make a list for each active game
        - [x] key is "game_<uid>"
        - [x] value is list of verbose moves (originating square, pieces, destination square)
    - [x] make a hash for each game
        - [x] key is "game_<uid>"
        - [x] values are key/values
            - [x] half_moves: int
            - [x] turn: 0/1
            - [x] white_can_castle_queenside
            - [x] black_can_castle_queenside
            - [x] white_can_castle_kingside
            - [x] black_can_castle_kingside
            - [x] half_moves_since_last_capture: null/moveNum
            - [x] board: probably a FEN
- [ ] create logic for
  - [x] create game
  - [ ] make move
    - [x] validate move
        - [x] pawn
            - [x] en passant
        - [x] rook
        - [x] bishop
        - [x] queen
        - [x] king
        - [x] knight
            - [x] write tests
        - [x] is it check?
        - [x] if castling, would it sweep through check?
    - [x] persist move
    - [x] update game state
        - see "make a hash for each game"
    - [x] test "get all legal moves"
        - [x] en passant results in the captured piece actually disappearing
        - [x] king is prohibited from putting himself into check, especially with another king
    - [ ] check if game is over
        - [ ] is it stalemate? (no possible moves and check is False)
        - [ ] is it checkmate? (no possible moves and check is True)
            - [ ] get all pieces putting king in check, not the current short-circuited way
        - [ ] if it is, persist it to "completed_games" (sqlite)
    - [ ] pawn promotion
    - [ ] make or find more tests
- [ ] create a basic API
  - [ ] /game
    - [ ] GET
    - [ ] POST
        - [ ] /create
    - [ ] PUT (maybe websockets instead)
        - [ ] /update
            - [ ] resign
            - [ ] draw
            - [ ] abandon
            - [ ] move
- [ ] create a basic web interface
  - [ ] no user registration or chat
  - [ ] whoever creates the game is player 1
  - [ ] the second to arrive to the game is player 2
  - [ ] everyone else is a spectator
  - [ ] maybe use websockets off the bat instead of polling


# Later

- [ ] game clock
- [ ] enforce move limit (draw)
- [ ] material tracking - points, pieces
- [ ] persist/serialize the board differently
  - instead of FEN, maybe a hash
- [ ] cache possible moves, this may not change for a given piece in certain conditions
  - [ ] build up a permanent cache of possible moves for a given board/FEN
      - [ ] look in this cache before trying to calculate
- [ ] detect cheating
- [ ] accounts/auth
- [ ] get_FEN_from_board, if it's more efficient than the other get_FEN (after a move), should replace it
- [ ] find shortcuts to limit computation
  - [ ] if a pawn, king, knight is sufficiently far away, no need to check whether it can put the opposing king in check
  - [ ] bitpacking?

