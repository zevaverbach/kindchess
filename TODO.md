- [x] create a basic DB
  - [x] use sqlite for completed games
    - [x] fields: uid and moves
    - [x] a function to store a completed game
  - [x] use Redis at first for the active games
    - [x] make a list for each active game
        - [x] key is "game_<uid>"
        - [x] value is list of verbose moves (originating square, pieces, destination square)
    - [x] make a hash for each game
        - [x] key is "game_<uid>"
        - [x] values are key/values
            - [x] half_moves: int
            - [x] turn: 0/1
            - [x] white_can_castle_queenside
            - [x] black_can_castle_queenside
            - [x] white_can_castle_kingside
            - [x] black_can_castle_kingside
            - [x] half_moves_since_last_capture: null/moveNum
            - [x] board: probably a FEN
- [x] create logic for
  - [x] create game
  - [x] make move
    - [x] validate move
        - [x] pawn
            - [x] en passant
        - [x] rook
        - [x] bishop
        - [x] queen
        - [x] king
        - [x] knight
            - [x] write tests
        - [x] is it check?
        - [x] if castling, would it sweep through check?
    - [x] persist move
    - [x] update game state
        - see "make a hash for each game"
    - [x] test "get all legal moves"
        - [x] en passant results in the captured piece actually disappearing
        - [x] king is prohibited from putting himself into check, especially with another king
    - [x] check if game is over
        - [x] is it stalemate? (no possible moves and check is False)
        - [x] is it checkmate? (no possible moves and check is True)
        - [x] if it is, persist it to "completed_games" (sqlite)
    - [x] pawn promotion
        - [x] implement it
- [ ] cache possible moves for every board
  - [ ] look in this cache before trying to calculate

- [ ] create a basic API
  - [ ] /game
    - [ ] GET
    - [ ] POST
        - [ ] /create
    - [ ] PUT (maybe websockets instead)
        - [ ] /update
            - [ ] resign
            - [ ] draw
            - [ ] abandon
            - [ ] move

- [ ] create a basic web interface
  - [ ] no user registration or chat
  - [ ] whoever creates the game is player 1
  - [ ] the second to arrive to the game is player 2
  - [ ] everyone else is a spectator
  - [ ] maybe use websockets off the bat instead of polling


# Later

- [ ] make or find more tests
    - [ ] could it ever be illegal to make the same move as a pawn when it's promoting with another piece?
        - this is how the pawn promotion move is tested once the promotion piece type is chosen
- [ ] game clock
- [ ] enforce move limit (draw)
- [ ] material tracking - points, pieces
- [ ] persist/serialize the board differently
  - instead of FEN, maybe a hash
- [ ] handle abandoned games
  - [ ] remove from redis, (maybe) add to db
- [ ] detect cheating
- [ ] accounts/auth
- [ ] get_FEN_from_board, if it's more efficient than the other get_FEN (after a move), should replace it
- [ ] find shortcuts to limit computation
  - [ ] if a pawn, king, knight is sufficiently far away, no need to check whether it can put the opposing king in check
  - [ ] bitpacking?

